# デコレーター（Decorator）について

このディレクトリには、Python のデコレーターについて学ぶためのサンプルコードが含まれています。

## デコレーターとは？

デコレーターは、既存の関数やメソッドの動作を変更したり、追加の機能を付け加えたりするための Python の機能です。`@`記号を使って関数の定義の上に記述します。

### 基本的な使い方

```python
def my_decorator(func):
    def wrapper():
        print("実行前の処理")
        result = func()
        print("実行後の処理")
        return result
    return wrapper

@my_decorator
def greet():
    print("こんにちは！")
```

この例では、`greet()`関数を呼び出すと、デコレーターによって追加された「実行前の処理」と「実行後の処理」が自動的に実行されます。

## サンプルファイルの説明

### `basic_decorator.py`

基本的なデコレーターの使い方を学ぶためのサンプルです。以下の内容が含まれています：

1. **最もシンプルなデコレーター**: 関数をラップして前後に処理を追加する
2. **引数を受け取る関数をデコレート**: `*args`と`**kwargs`を使って、どんな関数にも対応できるデコレーター
3. **引数を受け取るデコレーター**: デコレーター自体が引数を受け取るパターン（例: `@repeat(times=3)`）
4. **実行時間を測定するデコレーター**: 関数の実行時間を自動で測定する実用的な例
5. **クラスメソッド用のデコレーター**: クラスのメソッドに適用するデコレーターの例

## デコレーターとクラス継承の違い

### デコレーターの特徴

**メリット:**

- **柔軟性**: 関数単位で機能を追加できる
- **再利用性**: 同じデコレーターを複数の関数に適用できる
- **非侵入的**: 元のコードを変更せずに機能を追加できる
- **組み合わせ可能**: 複数のデコレーターを重ねて使える

**デメリット:**

- クラス全体に機能を追加するには、各メソッドに個別に適用する必要がある
- デコレーターの動作を理解するには、デコレーターの実装を見る必要がある

**使用例:**

```python
@log_decorator
@timing_decorator
def my_function():
    # 複数のデコレーターを組み合わせられる
    pass
```

### クラス継承の特徴

**メリット:**

- **明確な階層**: クラス間の関係が明確になる
- **一括適用**: 基底クラスの機能を全てのメソッドで使える
- **オブジェクト指向**: オブジェクト指向の設計パターンに沿っている
- **型安全性**: クラス階層が明確なので、型チェックがしやすい

**デメリット:**

- 特定のメソッドだけに機能を追加する場合でも、クラス全体の設計を考える必要がある
- 継承階層が深くなると、コードが複雑になる可能性がある
- 既存のクラスに機能を追加するには、クラス自体を変更するか、新しいクラスを作る必要がある

**使用例:**

```python
class BaseCalculator:
    def log_execution(self, func_name):
        print(f"実行: {func_name}")

class Calculator(BaseCalculator):
    def add(self, a, b):
        self.log_execution("add")
        return a + b
```

## どちらを使うべきか？

### デコレーターが適している場合

- **横断的関心事（Cross-cutting concerns）**: ログ出力、タイミング測定、認証チェックなど、複数の関数に共通して適用したい機能
- **既存のコードを変更したくない場合**: 既存の関数に機能を追加したいが、元のコードは変更したくない
- **関数単位で柔軟に適用したい場合**: 一部の関数だけに機能を追加したい

### クラス継承が適している場合

- **クラス全体に共通の機能を追加したい場合**: クラスの全てのメソッドで使いたい機能がある
- **オブジェクト指向の設計を重視する場合**: クラス間の関係を明確に表現したい
- **型安全性を重視する場合**: 型チェックや IDE の補完を活用したい

## FastAPI でのデコレーターの使用

FastAPI では、デコレーターを多用します：

```python
@app.get("/students")
def get_students():
    # @app.get() デコレーターでエンドポイントを定義
    pass

@app.post("/students")
def create_student():
    # @app.post() デコレーターでエンドポイントを定義
    pass
```

このように、`@app.get()`や`@app.post()`などのデコレーターを使って、簡単に API エンドポイントを定義できます。デコレーターの仕組みを理解することで、FastAPI のコードがより理解しやすくなります。

## 実行方法

各サンプルファイルは独立して実行できます：

```bash
# 基本的なデコレーターのサンプル
python basic_decorator.py
```

## まとめ

- **デコレーター**: 関数単位で機能を追加する柔軟な方法。横断的関心事に適している。
- **継承**: クラス全体に機能を追加する方法。オブジェクト指向の設計に適している。
- **FastAPI**: デコレーターを多用するため、デコレーターの理解が重要。

両方のアプローチを理解して、状況に応じて適切な方法を選択できるようになりましょう！
